import MacrosForStroblMocks
import XCTest
@testable import MacrosForStroblMocksClient

@UsesStroblMocks
final class Test05OptionSetValueTests: XCTestCase {
    
    @StroblMock var cookieStore: MockCookieStoring!
    @StroblMock var urlSession: MockDataTaskCreating!
    @StroblMock var dateFactory: MockDateCreating!
    @StroblMock var jsonDecoder: MockJSONDecoding!
    @StroblMock var jsonEncoder: MockJSONEncoding!
    @StroblMock var jsonSerializer: MockJSONSerializing!
    @StroblMock var semaphore: MockSemaphore!

    override func setUpWithError() throws {
        cookieStore = MockCookieStoring()
        urlSession =  MockDataTaskCreating()
        dateFactory = MockDateCreating()
        jsonDecoder = MockJSONDecoding()
        jsonEncoder = MockJSONEncoding()
        jsonSerializer = MockJSONSerializing()
        semaphore = MockSemaphore()
        
        jsonSerializer.reset()
    }

    func testNothingCalled_verifyStroblMocksUsedDoesNotFail() {
        
        // Nothing in any mock called. No errors should be reported.
        verifyStroblMocksUnused()
    }

    func testSemaphoreSignalCalled_verifyStroblMocksUsedReportsFailure() {
        _ = semaphore.signal()
        let expectedDescription = "failed - 'semaphore.calledMethods' == '[.signalCalled]'"
        let options = XCTExpectedFailure.Options()
        options.issueMatcher = { issue in
            issue.type == .assertionFailure && issue.compactDescription == expectedDescription
        }

        // Test needs to be run to get failure.
        // It should result in the following message:
        //
        //      'semaphore.calledMethods' == '[.signalCalled]'
        //
        XCTExpectFailure("This text exercises code generated by @UsesStroblMocks and should fail", options: options)
        verifyStroblMocksUnused()
    }

    func testDateFactoryTimeIntervalSinceNowCalled_verifyStroblMocksUsedReportsFailure() {
        dateFactory.dateTimeIntervalSinceNowReturnValue = Date.now
        _ = dateFactory.date(timeIntervalSinceNow: 1234)
        let expectedDescription = "failed - The following problems were identified:\n\t\'dateFactory.calledMethods\' == \'[.dateTimeIntervalSinceNowCalled]\'\n\t\'dateFactory.assignedParameters\' == \'[.timeIntervalSinceNow]\'"
        let options = XCTExpectedFailure.Options()
        options.issueMatcher = { issue in
            issue.type == .assertionFailure && issue.compactDescription == expectedDescription
        }

        // Test needs to be run to get failure.
        // It should result in the following message:
        //
        //      failed - The following problems were identified:
        //          'dateFactory.calledMethods' == '[.dateTimeIntervalSinceNowCalled]'
        //          'dateFactory.assignedParameters' == '[.timeIntervalSinceNow]'
        //
        XCTExpectFailure("This text exercises code generated by @UsesStroblMocks and should fail", options: options)
        verifyStroblMocksUnused()
    }

    func testJSONSerializerDataWithJSONObjectCalled_verifyStroblMocksUsedReportsFailure() throws {
        _ = try MockJSONSerializing.data(withJSONObject: "String", options: [])
        let expectedDescription = "failed - The following problems were identified:\n\t'jsonSerializer.calledStaticMethods' == '[.dataWithJSONObjectObjOptionsOptCalled]'\n\t'jsonSerializer.assignedStaticParameters' == '[.obj, .opt]'"
        let options = XCTExpectedFailure.Options()
        options.issueMatcher = { issue in
            issue.type == .assertionFailure && issue.compactDescription == expectedDescription
        }

        // Test needs to be run to get failure.
        // It should result in the following message:
        //
        //      failed - The following problems were identified:
        //          'jsonSerializer.calledStaticMethods' == '[.dataWithJSONObjectObjOptionsOptCalled]'
        //          'jsonSerializer.assignedStaticParameters' == '[.obj, .opt]'
        //
        XCTExpectFailure("This text exercises code generated by @UsesStroblMocks and should fail", options: options)
        verifyStroblMocksUnused()
    }

    func testJSONSerializerAndDateFactoryCalled_calledObjectsReportedToVerifyStroblMocks_verifyStroblMocksUsedDoesNotFail() throws {
        dateFactory.dateTimeIntervalSinceNowReturnValue = Date.now
        _ = dateFactory.date(timeIntervalSinceNow: 1234)
        _ = try MockJSONSerializing.data(withJSONObject: "String", options: [])
        
        verifyStroblMocksUnused(except: [.dateFactory, .jsonSerializer])
        XCTAssertEqual(dateFactory.calledMethods, [.dateTimeIntervalSinceNowCalled])
        XCTAssertEqual(dateFactory.assignedParameters, [.timeIntervalSinceNow])
        XCTAssertEqual(dateFactory.timeIntervalSinceNow, 1234)
        XCTAssertEqual(MockJSONSerializing.calledStaticMethods, [.dataWithJSONObjectObjOptionsOptCalled])
        XCTAssertEqual(MockJSONSerializing.assignedStaticParameters, [.obj, .opt])
        XCTAssertTrue(MockJSONSerializing.obj is String)
        if let obj = MockJSONSerializing.obj as? String {
            XCTAssertEqual(obj, "String")
        }
        XCTAssertEqual(MockJSONSerializing.opt, [])
    }

}
